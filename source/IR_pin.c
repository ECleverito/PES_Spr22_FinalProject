// ***********************************************
// ***********************************************
// **********	PES Spring 2022			**********
// **********	Final Project:			**********
// **********	Universal IR Receiver	**********
// ***********************************************
// ***********************************************
// **********	By: Erich Clever		**********
// **********	Date: May 2, 2022		**********
// ********** Instructor: Howdy Pierce	**********
// ***********************************************
// ***********************************************
// **********	Version: 1.0			**********
// ***********************************************
// ********** 	 File: IR_pin.c			**********
// ***********************************************
// Code for initialization of the pin on which
// the IR sensor is connected (PORT A, 3) as well
// as the interrupt routine
// ***********************************************

#include "MKL25Z4.h"

#include "IR_pin.h"

#include "LEDs.h"
#include "TPM.h"

#include "stdbool.h"
#include "stdio.h"

//Global flags for generating
//IR data in the main loop
bool newIRMessage = 0;
bool bitFlag = false;
bool IR_bit_Zero_Flag = false;
bool IR_bit_One_Flag = false;

void IR_pin_init(){

	//Initialize TPM0 first. This is
	//used for decoding the IR signal.
	TPM0_init();

	//Send the clock to PORTA
	SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK;

	//Generate interrupt on detection of either edge and
	//for GPIO mode in multiplexer
	PORTA->PCR[13] = PORT_PCR_MUX(1) | PORT_PCR_IRQC(11);

	//Set pin 3 as input
	GPIOA->PDDR &= ~(1 << IR_PIN);

	//Enable PORT interrupts
	NVIC_SetPriority(PORTA_IRQn, 2);
	NVIC_ClearPendingIRQ(PORTA_IRQn);
	NVIC_EnableIRQ(PORTA_IRQn);

}

void PORTA_IRQHandler(){

	//Determine the time since the last
	//edge generated by the IR sensor then
	//reset promptly after
	uint16_t pulseDuration = TPM0->CNT;
	TPM0->CNT = 0;

	//Check to see if overflow flag is set,
	//as this indicates that it has been too
	//long since actual data has been sent
	//for this to be valid NEC protocol data
	if(TPM0->SC & TPM_SC_TOF_MASK){

		//Clear overflow flag by setting it
		TPM0->SC |= TPM_SC_TOF_MASK;
		newIRMessage = true;
		bitFlag = false;
	}
	else{

		//Using NEC protocol, "leader code"
		//is first sent always with much longer
		//duration than data bits. It can be
		//ignored as it is not unique to other
		//signals
		if(pulseDuration > LEADER_CODE_DURATION){
			//Leader code. Can ignore.
		}
		else if(bitFlag){
			//If bit data has started to be
			//transmitted, this flag will be
			//set and we will now be checking
			//for data with duration longer
			//than what qualifies as a one
			if( pulseDuration > ONE_DURATION ){
				IR_bit_One_Flag = 1;

			}
			else{
				//If not a one, then must be zero
				IR_bit_Zero_Flag = 1;
			}
			bitFlag=0;

		}
		else
			bitFlag=1;

	}

	//Clear interrupt flag
	PORTA->ISFR = 0xffffffff;

}
